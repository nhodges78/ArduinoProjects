# RGB Minecraft Ore Block Lamp

## Project Summary

This project uses 3D model and printing files created by [jorgenp on Thingiverse](https://www.thingiverse.com/thing:3625720). The final build of this project uses a Makefun Nano (equivalent to Arduino Nano) with the control program developed in Arduino IDE ver. 1.8.13. The Nano was chosen over the Uno for two reasons; the footprint is smaller with an identical pinout and functionality to the larger Uno, and the 3D print files have a space designed to accomodate for the Nano rather than the Uno. An Elegoo Uno R3 (Arduino Uno equivalent) was used for testing and developing the circuit since it was the only microcontroller I possessed at the time. After proof of concept was achieved on the Uno, the process of transferring the functionality to the Nano was incredibly simple - the only changes to the code of the Nano were pin names. After soldering new header pins on a new Nano board, the circuit's functionality was tested with the new board. Following this, the process of mounting the components inside the 3D printed cube began. First, Krazy Glue was used to glue the Nano in its designated seat in the rear of the cube. A small amount of glue was used on both sides near the front of the board, enough to hold the board in place when plugging in a micro-USB cable but not so much that would hinder removing the board if needed. Next, some circuit wire was cut and the end were stripped so that they could be soldered to two pins of each pushbutton. I would have liked to use different-colored wire but I only had a strand of red circuit wire at the time of construction, so I used a black Sharpie to mark the ground wires of both pushbuttons. As for the other components, they were kept in the small breadboard. The 220-ohm resistor leads were cut so that the resistors would not contribute to blocking the light emitted by the RGB LED and to lessen the likelihood that leads of unique resistors bumped into one another and caused functional issues. Some black jumper wires (specifically designed for breadboarding) were placed in the breadboard to route common ground to the two pushbuttons and the cathode of the LED. The wires of the output pins of the pushbuttons are pushed (as well as they can be) to the inside corners of the cube to minimize obstruction of the light emitted by the LED. They are put into the breadboard before being routed to the Nano because the Nano has male headers and I didn't want to solder the wires to the Nano's pins since the breadboard was being utilized. Wires used to interface between the Nano and the breadboard are female-male jumper wires with the female side to the Nano and the male side to the breadboard. These wires are organized using twist-ties to minimize thier obstruction of the light emitted by the LED. Note that the test circuits and the final build use different colors of wires since I had a limited number of female-male jumper wires. The breadboard itself is glued to the support structure in the center of the cube with the RGB LED towards the center of the breadboard. Functionally, the ore block has two pushbuttons that cycle through all the main "ore" colors of Minecraft ore blocks (except coal) and dim/brighten the selected light.

## Circuit Description

The original test circuit was controlled by an Elegoo Uno R3 (Arduino Uno equivalent), shown in [this image](https://github.com/nhodges78/ArduinoProjects/blob/master/MinecraftLamp/Circuit/Circuit_Rev1.jpg), and is detailed further in the corresponding [schematic](https://github.com/nhodges78/ArduinoProjects/blob/master/MinecraftLamp/Circuit/Circuit_Rev1.png). A brief functional demonstration of the working circuit can be found [on YouTube](https://www.youtube.com/watch?v=98_461uSXLU). Pinouts and functionality are similar enough between Arduino Uno and Arduino Nano (same microcontroller), so the smaller footprint of the Nano is exploited to save space inside the lamp. The current version of the circuit is controlled by a Makefun Nano (Arduino Nano equivalent), shown in [this image](https://github.com/nhodges78/ArduinoProjects/blob/master/MinecraftLamp/Circuit/Circuit_Rev2_Nano.jpg), and is detailed a little more in the corresponding [schematic](https://github.com/nhodges78/ArduinoProjects/blob/master/MinecraftLamp/Circuit/Circuit_Schematic_Rev2_Nano.png).

### Components
* (3) 220 ohm resistors
* (1) common-cathode RGB LED
* (2) pushbuttons

### Connections and Functionality
* (1) 220 ohm resistor for each (R, G, B) pin of the LED with common pin to ground. Each RGB pin is controlled by a PWM output pin (9, 10, 11, respectively, for the Uno and Nano).

* (2) pushbuttons with two pins connected to digital pin 7 of the Uno or pin 3 of the Nano (brightness control) and digital pin 8 of the Uno or pin 2 of the Nano (color cycle) with internal 20 kohm - 50 kohm pull-up resistors enabled for the input pins and two pins connected to common ground.

* Pushing the left-hand button (digital pin 8 for Uno or 2 for Nano) cycles through all major colors of "ore blocks" (brownish, yellow, cyan, green, red, blue) and one extra color (purple) just for fun.

* A second pushbutton (digital pin 7 for Uno or 3 for Nano) with connections identical to the first cycles through brightness levels of the LED by tweaking PWM output values of pins 9, 10, and 11 to alternate between duty cycles of 100% (full bright) and 10% (dimmed).

## Program Description
The program begins by declaring necessary globals:
* Pin numbers for RGB pins of LED and for the color cycle and brightness pushbuttons
* Variables for tracking presses on the first (left-hand) and second (right hand) pushbuttons
* Two 3-element arrays for current and updated RGB values (used in brightness-changing function)
* Two variables for holding the current and previous "ore block" color values (used in brightness-changing function)

The `setup` code block sets the RGB-control pins as outputs and the button-reader pins as inputs before the main looping block begins. The main `loop` block contains two primary `if` blocks, one for detecting the color cycle button pushes and the other for brightness button pushes. The first block begins with a 250 ms delay to mitigate bouncing of the pushbutton when pressed. It then checks to see if the number of logged presses is beyond the number of available color options (6) and resets presses to 0 if it is. The number of logged presses is put into a `switch` statement that sequentially chooses a set of RGB values to generate a color based on how many times the button has been pressed. The set of colors loops back to the start and repeats after the end of the `switch` statements is reached. At the end of the first `if` block, the number of button presses is incremented and the block is exited. The reason the number of presses is post-incremented is so that the color-selection of the `switch` statement starts at index 0 rather than 1. A function called `setRGB` is created to handle adjusting the RGB values sent to the LED in order to create the ore colors from the three arguments (R, G, B) given to it. The function also saves the three values in order (R, G, B) to indices 0-2 of the `currentRGB` integer array to make note of the RGB values currently in use. This array is used in the next primary `if` block for adjusting brightness.

The second primary `if` block begins with a delay as with the first block. Following this, the current color selection is noted by checking the current number of color cycle button presses (corresponds to the case numbers in the `switch` statement of the first `if` block). After that, the press count of the second button is checked, though the name of the variable is a little misleading. Rather than store the number of presses of the button directly, the `pressCount2` variable alternates between 0 (initial value) and 1 depending on certain conditions. The first `if` statment of the block executes be default on the first pass of the program and is responsible for dimming the light of the LED. To do that, the current RGB values (in `currentRGB` array) are divided by a constant to adjust the duty cycle of each RGB component. The resulting values are put into the same indices of the `newRGB` float array and are typecasted to integer values when passed as arguments to the `setRGB` function, used to enact the brightness change. Dividing all RGB values by the same constant ensures that the RGB value ratio is held constant, maintaining the same color when dimming the LED. The reason `newRGB`'s elements are typecasted to integers rather than saving them directly as integers in the array is because the floating-point values resulting from the intitial dimming operation are needed to simplify the reversing (brightening) process. In other words, multiplying the floating point result of the intitial division by the constant it was divided by results in the exact original value. The first `if` statement ends by changing the `pressCount2` variable to 1 so that the next push of the brightness button triggers the second conditional block, and saves the current color selection to the previous color selection variable. The second `if` statement of the primary block (`else if`) triggers when the button has been pressed once before (`pressCount2 == 1`). In order to prevent errors in color selection and dimming, this block uses an `if-else` pair to determine if the current color selection matches the previous color selection. If it does, then the current color selection is the dimmed version of the color selection and needs to be brightened back to full brightness, which is done by multiplying the float values in `newRGB` by the same constant they were divided by when dimming the LED. If the previous and current color selection do not match, then a new color is currently in use which is not currently in dimmed mode, meaning that the current color must be dimmed before it can be returned to full brightness. After one of the two cases executes, the previous color is updated to the current color and the `else-if` block exits. Once the entire `if` block executes, the program loops back to the start and repeats.
